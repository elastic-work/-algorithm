## 机器人能否返回原点
在二维平面上,有一个机器人从原点(0,0)开始.给出它的移动顺序,判断这个机器人在完成移动后是否在(0,0)处结束.移动顺序由字符串表示.字符move[i]表示第i次移动.机器人的有效动作有R(右),L(左),U(上)和D(下).如果机器人在完成所有动作后返回原点,则返回true.否则,返回false.注意:机器人"面朝"的方向无关紧要."R"将始终使机器人向右移动一次,"L"将始终向左移动等.此外,假设每次移动机器人的移动幅度相同.

#### 示例1:
```
   输入:"UD"
   输出:true
   解释:机器人向上移动一次,然后向下异动一次.所有动作都具有相同的幅度,因此它最终回到它开始的原点.因此,我们返回true.
```
#### 示例2:
```
   输入:"LL"
   输出:false
   解释:机器人向左移动两次,它最终位于原点的左侧,距原点有两次"移动"的距离.我们返回false,因此它移动结束时没有返回原点.
```


#### 解题思路

我们可以把二维平面看作是一个平面直角坐标系,把机器人的原点看作坐标系上的原点,上下左右操作移动一次看作是移动一个单位.
即平面直角坐标系上,Y轴的移动只能是上(U)下(D),X轴的移动只能是左(L)右(R).

由上诉得出,机器人只要在Y轴移动的位置上下次数一样,即在Y轴的位置会回到Y轴的原点,
在X轴移动位置左右次数一样,即X轴的位置会回到原点.


即得出解题代码如下(java):

```java
class Robot{
 public boolean judgeCircle(String moves) {
        if (Objects.isNull(moves) || moves.trim().length()<=0){
            return false;
        }
        int x=0;
        int y=0;
        char [] chars = moves.toCharArray();
        for (int i=0;i<chars.length;i++){
           switch (chars[i]){
               case 'R':
                   x++;
                   break;
               case 'L':
                   x--;
                   break;
               case 'U':
                   y++;
                   break;
               case 'D':
                   y--;
                   break;
               default:
                   return false;
           }
        }
        return x==0&&y==0;
    }
}
```

#### 复杂度分析

- 时间复杂度: O(N),其中N标识moves指令串的长度.因为我们只需要遍历一遍字符串即可.
- 空间复杂度:O(1).我们只需要常数的空间来存放若干变量.



